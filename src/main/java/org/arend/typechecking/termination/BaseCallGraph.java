package org.arend.typechecking.termination;

/*Generated by MPS */

import java.util.*;

public abstract class BaseCallGraph<T> {
  private HashMap<T, HashMap<T, HashSet<BaseCallMatrix<T>>>> myGraph = new HashMap<>();
  private boolean isCompositionClosed = false;

  BaseCallGraph() {
  }

  BaseCallGraph(BaseCallGraph<T> g) {
    HashMap<T, HashMap<T, HashSet<BaseCallMatrix<T>>>> newGraph;
    HashMap<T, HashMap<T, HashSet<BaseCallMatrix<T>>>> oldGraph = g.myGraph;
    int myNewEdges;

    do {
      myNewEdges = 0;
      newGraph = new HashMap<>();

      for (T vDom : oldGraph.keySet()) {
        HashMap<T, HashSet<BaseCallMatrix<T>>> outboundEdges = oldGraph.get(vDom);
        for (T vCodom : outboundEdges.keySet()) {
          for (BaseCallMatrix<T> edge : outboundEdges.get(vCodom)) {
            append(edge, newGraph);
          }
        }
      }

      for (T vDom : oldGraph.keySet()) {
        HashMap<T, HashSet<BaseCallMatrix<T>>> outboundEdges = oldGraph.get(vDom);
        for (T vCodom : outboundEdges.keySet()) {
          for (BaseCallMatrix<T> edge : outboundEdges.get(vCodom)) {
            HashMap<T, HashSet<BaseCallMatrix<T>>> outboundEdges2 = oldGraph.get(edge.getCodomain());
            if (outboundEdges2 != null) {
              for (HashSet<BaseCallMatrix<T>> edgesSheaf : outboundEdges2.values()) {
                for (BaseCallMatrix<T> edge2 : edgesSheaf) {
                  if (append(new CompositeCallMatrix<>(edge, edge2), newGraph)) {
                    myNewEdges++;
                  }
                }
              }
            }
          }
        }
      }
      oldGraph = newGraph;
    } while (myNewEdges > 0);

    myGraph = newGraph;
    isCompositionClosed = true;
  }

  public void add(Set<BaseCallMatrix<T>> set) {
    for (BaseCallMatrix<T> cm : set) {
      append(cm, myGraph);
    }
  }

  protected abstract String getLabel(T vertex);

  protected abstract void formErrorMessage(T vertex, Set<RecursiveBehavior<T>> behavior);

  @Override
  public String toString() {
    StringBuilder result = new StringBuilder();
    for (T vDom : myGraph.keySet()) {
      for (T vCodom : myGraph.get(vDom).keySet()) {
        result.append(getLabel(vDom)).append(" -> ").append(getLabel(vCodom)).append("\n ");
        for (BaseCallMatrix<T> cm : myGraph.get(vDom).get(vCodom)) {
          result.append(cm.toString()).append("\n");
        }
      }
    }
    return result.toString();
  }

  private static <T> boolean append(BaseCallMatrix<T> cm, HashMap<T, HashMap<T, HashSet<BaseCallMatrix<T>>>> graph) {
    HashSet<BaseCallMatrix<T>> set;
    HashMap<T, HashSet<BaseCallMatrix<T>>> map;
    if (!(graph.containsKey(cm.getDomain()))) {
      map = new HashMap<>();
      set = new HashSet<>();
      set.add(cm);
      map.put(cm.getCodomain(), set);
      graph.put(cm.getDomain(), map);
      return true;
    } else {
      map = graph.get(cm.getDomain());
      if (!(map.containsKey(cm.getCodomain()))) {
        set = new HashSet<>();
        set.add(cm);
        map.put(cm.getCodomain(), set);
        return true;
      } else {
        set = map.get(cm.getCodomain());
        boolean alreadyContainsEqual = false;

        for (BaseCallMatrix<T> c : set) {
          if (cm.equals(c)) {
            alreadyContainsEqual = true;
            break;
          }
        }

        if (!(alreadyContainsEqual)) {
          set.add(cm);
        }

        return !alreadyContainsEqual;
      }
    }
  }

  public boolean checkTermination() {
    boolean result = true;
    for (T v : myGraph.keySet()) {
      RecursiveBehaviors<T> rbs = new RecursiveBehaviors<>(this, v);
      List<String> order = rbs.findTerminationOrderAnnotated();
      if (order == null) {
        result = false;
        HashSet<RecursiveBehavior<T>> rbs2 = new HashSet<>();
        if (rbs.myBestRbAttained != null) {
          rbs2.addAll(rbs.myBestRbAttained.onlyMinimalElements());
        }
        formErrorMessage(v, rbs2);
      }
    }
    return result;
  }

  private static class RecursiveBehaviors<T> {
    private T myBasepoint = null;
    private final Set<RecursiveBehavior<T>> myBehaviors = new HashSet<>();
    private int myLength = -1;
    private RecursiveBehaviors<T> myBestRbAttained = null;

    private RecursiveBehaviors(BaseCallGraph<T> graph, T v) {
      this(graph.myGraph.get(v).get(v));
      if (!graph.isCompositionClosed) throw new IllegalArgumentException();
      myBasepoint = v;
    }

    private RecursiveBehaviors(Set<BaseCallMatrix<T>> callMatrices) {
      if (callMatrices != null)
        for (BaseCallMatrix<T> m : callMatrices) myBehaviors.add(new RecursiveBehavior<>(m));
      if (!myBehaviors.isEmpty()) {
        Iterator<RecursiveBehavior<T>> i = myBehaviors.iterator();
        myLength = i.next().getLength();
        while (i.hasNext()) if (myLength != i.next().getLength()) throw new IllegalArgumentException();
      }
    }

    private RecursiveBehaviors() {
    }

    private RecursiveBehaviors<T> createShorterBehavior(int i) {
      RecursiveBehaviors<T> result = new RecursiveBehaviors<>();
      for (RecursiveBehavior<T> rb : myBehaviors) {
        switch (rb.behavior.get(i)) {
          case LessThan:
            continue;
          case Equal:
            result.myBehaviors.add(new RecursiveBehavior<>(rb, i));
            continue;
          case Unknown:
            return null;
        }
      }
      result.myLength = myLength - 1;
      result.myBasepoint = myBasepoint;
      return result;
    }

    private List<Integer> findTerminationOrder(RecursiveBehaviors<T> recBehaviors, List<Integer> indices) {
      if (recBehaviors == null) throw new IllegalArgumentException();

      if (recBehaviors.myBehaviors.isEmpty()) return indices;
      if (recBehaviors.myLength == 0) return null;

      if (myBestRbAttained == null || myBestRbAttained.myLength > recBehaviors.myLength)
        myBestRbAttained = recBehaviors;

      for (int i = 0; i < recBehaviors.myLength; i++) {
        RecursiveBehaviors<T> shorterBehavior = recBehaviors.createShorterBehavior(i);
        if (shorterBehavior != null) {
          List<Integer> shorterIndices = new LinkedList<>(indices);
          shorterIndices.remove(i);
          List<Integer> termOrder = findTerminationOrder(shorterBehavior, shorterIndices);
          if (termOrder != null) {
            termOrder.add(0, indices.get(i));
            return termOrder;
          }
        }
      }

      return null;
    }

    private List<Integer> findTerminationOrder() {
      List<Integer> indices = new LinkedList<>();
      for (int i = 0; i < myLength; i++) indices.add(i);
      return findTerminationOrder(this, indices);
    }

    private List<String> findTerminationOrderAnnotated() {
      List<Integer> to = findTerminationOrder();
      if (to == null) return null;
      if (!myBehaviors.isEmpty()) {
        RecursiveBehavior<T> rb = myBehaviors.iterator().next();
        List<String> result = new ArrayList<>();
        for (Integer i : to) result.add(rb.labels.get(i));
        return result;
      }
      return new ArrayList<>(); // recursive behaviors set is empty -- there were no recursive call at all
    }

    private Set<RecursiveBehavior<T>> onlyMinimalElements() {
      Set<RecursiveBehavior<T>> result = new HashSet<>();
      for (RecursiveBehavior<T> rb : myBehaviors) {
        boolean containsSmaller = false;
        Set<RecursiveBehavior<T>> greater = new HashSet<>();
        for (RecursiveBehavior<T> rb2 : result)
          if (rb2.leq(rb)) {
            containsSmaller = true;
            break;
          } else if (rb.leq(rb2)) {
            greater.add(rb2);
          }
        result.removeAll(greater);
        if (!containsSmaller) result.add(rb);
      }
      return result;
    }

  }

}
